@@eol_comments :: /(#.*?$)/ 


main
    =
    {def_statement | top_statement | ML_STRING}
    ;


def_statement
    =
      typedef
    | entity_def
    | implementation_def
    | relation
    | index
    | implement_def
    ;


typedef
    =
      'typedef' ID 'as' ns_ref 'matching' (REGEX | expression)
    | 'typedef' CLASS_ID 'as' constructor
    ;


entity_def
    =
    ('entity' CLASS_ID ['extends' class_ref {',' class_ref}])
    ':'
    [ML_STRING]
    {entity_body}
    'end'
    ;


implementation_def
    =
    'implementation' ID ['for' class_ref] implementation
    ;


index
    =
    'index' class_ref '(' ID {',' ID} ')'
    ;


implement_def
    =
    'implement' class_ref 'using' ns_ref {',' ns_ref} ['when' expression]
    ;


relation_end
    =
    class_ref ID
    ;


relation_link
    =
    '<-' | '->' | '--'
    ;


multiplicity_body
    =
      &(INT) INT
    | &(INT ':') INT ':'
    | &(INT ':' INT) INT ':' INT
    | &(':' INT) ':' INT
    ;


multiplicity
    =
    '[' multiplicity_body ']'
    ;


relation
    =
    (left_end:relation_end left_m:multiplicity)
    relation_link
    (right_m:multiplicity right_end:relation_end)
    ;


top_statement
    =
      &('for') 'for' ID 'in' variable implementation
    | variable '=' operand
    | call
    ;


implementation
    =
    ':' [ML_STRING] {statement} 'end'
    ;


statement
    =
    top_statement
    ;


parameter
    =
    ID '=' operand
    ;


constructor
    =
    class_ref '(' [param_list] ')'
    ;


param_list
    =
    parameter {',' parameter} [',']
    ;


operand
    =
    constant | list_def | index_lookup | call | variable
    ;


constant
    =
    TRUE | FALSE | STRING | INT | FLOAT | REGEX | ML_STRING
    ;


list_def
    =
    '[' operand {',' operand} [','] ']'
    ;


index_arg
    =
    param_list
    ;


index_lookup
    =
    class_ref '[' index_arg ']'
    ;


entity_body
    =
    ns_ref ID ['=' constant]
    ;


ns_ref
    =
    ID {'::' ID}
    ;


class_ref
    =
    {ns+:ID '::'} CLASS_ID
    ;


variable
    =
    {ns+:ID '::'} var:ID {'.' attr+:ID}
    ;


arg_list
    =
    operand {',' operand} [',']
    ;


call
    =
    &(ns_ref '(') function_call | &(class_ref '(') constructor
    ;


function_call
    =
    ns_ref '(' [arg_list] ')'
    ;


un_op
    =
    'not'
    ;


cmp_op
    =
    '==' | '!=' | '<=' | '>=' | '<' | '>'
    ;


cmp
    =
      &(operand 'in') operand 'in' in_oper
    | &(operand cmp_op) operand cmp_op operand
    | function_call
    ;


log_op
    =
    'and' | 'or'
    ;


in_oper
    =
    list_def | variable
    ;


log_oper
    =
    cmp | TRUE | FALSE
    ;


log_expr
    =
    &(log_oper log_op) log_oper log_op log_expr | log_oper
    ;


expression
    =
      '(' expression ')' [log_op expression]
    | &(log_expr log_op) log_expr log_op '(' expression ')'
    | log_expr
    ;


TRUE
    =
    'true'
    ;


FALSE
    =
    'false'
    ;


ID
    =
    (/[a-z_][a-zA-Z0-9_-]*/)
    ;


CLASS_ID
    =
     (/[A-Z][a-zA-Z_0-9-]*/)
    ;


INT
    =
    {/[0-9]/}+
    ;


FLOAT
    =
      {/['0'-'9']/}+ '.' {/['0'-'9']/} [EXPONENT]
    | '.' {/['0'-'9']/}+ [EXPONENT]
    | {/['0'-'9']/}+ EXPONENT
    ;
    
COMMENT
    =
      '//' {!('\\n' | '\\r') /./} ['\\r'] '\\n' (* {$channel=HIDDEN;} *)
    | '#' {!('\\n' | '\\r') /./} ['\\r'] '\\n' (* {$channel=HIDDEN;} *)
    | '/*' {(/\w+|\S+/)} '*/' (* {$channel=HIDDEN;} *)
    ;


WS
    =
    (' ' | '\\t' | '\\r' | '\\n') (* {$channel=HIDDEN;} *)
    ;


ML_STRING
    =
    '"""' {(/\w+|\S+/)} '"""'
    ;


STRING
    =
    /"[^"]*"/ 
    ;


REGEX
    =
    '/' {!('/') /./} '/'
    ;


EXPONENT
    =
    ('e' | 'E')
    [
    '+' | '-'
    ]

    {/['0'-'9']/}+
    ;


HEX_DIGIT
    =
    (/['0'-'9']/ | /['a'-'f']/ | /['A'-'F']/)
    ;


ESC_SEQ
    =
      '\\\\' ('b' | 't' | 'n' | 'f' | 'r' | '\\"' | "\\'" | '\\\\')
    | UNICODE_ESC
    | OCTAL_ESC
    ;


OCTAL_ESC
    =
      '\\\\' (/['0'-'3']/) (/['0'-'7']/) (/['0'-'7']/)
    | '\\\\' (/['0'-'7']/) (/['0'-'7']/)
    | '\\\\' (/['0'-'7']/)
    ;


UNICODE_ESC
    =
    '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    ;

