#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS, generic_main  # noqa


__version__ = (2016, 4, 8, 22, 0, 35, 4)

__all__ = [
    'imperaParser',
    'imperaSemantics',
    'main'
]

KEYWORDS = set([])


class imperaParser(Parser):
    def __init__(self,
                 whitespace=None,
                 nameguard=None,
                 comments_re=None,
                 eol_comments_re='(#.*?$)',
                 ignorecase=None,
                 left_recursion=True,
                 keywords=KEYWORDS,
                 **kwargs):
        super(imperaParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            keywords=keywords,
            **kwargs
        )

    @graken()
    def _main_(self):

        def block0():
            with self._choice():
                with self._option():
                    self._def_statement_()
                with self._option():
                    self._top_statement_()
                with self._option():
                    self._ML_STRING_()
                self._error('no available options')
        self._closure(block0)

    @graken()
    def _def_statement_(self):
        with self._choice():
            with self._option():
                self._typedef_()
            with self._option():
                self._entity_def_()
            with self._option():
                self._implementation_def_()
            with self._option():
                self._relation_()
            with self._option():
                self._index_()
            with self._option():
                self._implement_def_()
            self._error('no available options')

    @graken()
    def _typedef_(self):
        with self._choice():
            with self._option():
                self._token('typedef')
                self._ID_()
                self._token('as')
                self._ns_ref_()
                self._token('matching')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._REGEX_()
                        with self._option():
                            self._expression_()
                        self._error('no available options')
            with self._option():
                self._token('typedef')
                self._CLASS_ID_()
                self._token('as')
                self._constructor_()
            self._error('no available options')

    @graken()
    def _entity_def_(self):
        with self._group():
            self._token('entity')
            self._CLASS_ID_()
            with self._optional():
                self._token('extends')
                self._class_ref_()

                def block0():
                    self._token(',')
                    self._class_ref_()
                self._closure(block0)
        self._token(':')
        with self._optional():
            self._ML_STRING_()

        def block1():
            self._entity_body_()
        self._closure(block1)
        self._token('end')

    @graken()
    def _implementation_def_(self):
        self._token('implementation')
        self._ID_()
        with self._optional():
            self._token('for')
            self._class_ref_()
        self._implementation_()

    @graken()
    def _index_(self):
        self._token('index')
        self._class_ref_()
        self._token('(')
        self._ID_()

        def block0():
            self._token(',')
            self._ID_()
        self._closure(block0)
        self._token(')')

    @graken()
    def _implement_def_(self):
        self._token('implement')
        self._class_ref_()
        self._token('using')
        self._ns_ref_()

        def block0():
            self._token(',')
            self._ns_ref_()
        self._closure(block0)
        with self._optional():
            self._token('when')
            self._expression_()

    @graken()
    def _relation_end_(self):
        self._class_ref_()
        self._ID_()

    @graken()
    def _relation_link_(self):
        with self._choice():
            with self._option():
                self._token('<-')
            with self._option():
                self._token('->')
            with self._option():
                self._token('--')
            self._error('expecting one of: -- -> <-')

    @graken()
    def _multiplicity_body_(self):
        with self._choice():
            with self._option():
                with self._if():
                    with self._group():
                        self._INT_()
                self._INT_()
            with self._option():
                with self._if():
                    with self._group():
                        self._INT_()
                        self._token(':')
                self._INT_()
                self._token(':')
            with self._option():
                with self._if():
                    with self._group():
                        self._INT_()
                        self._token(':')
                        self._INT_()
                self._INT_()
                self._token(':')
                self._INT_()
            with self._option():
                with self._if():
                    with self._group():
                        self._token(':')
                        self._INT_()
                self._token(':')
                self._INT_()
            self._error('no available options')

    @graken()
    def _multiplicity_(self):
        self._token('[')
        self._multiplicity_body_()
        self._token(']')

    @graken()
    def _relation_(self):
        with self._group():
            self._relation_end_()
            self.name_last_node('left_end')
            self._multiplicity_()
            self.name_last_node('left_m')
        self._relation_link_()
        with self._group():
            self._multiplicity_()
            self.name_last_node('right_m')
            self._relation_end_()
            self.name_last_node('right_end')

        self.ast._define(
            ['left_end', 'left_m', 'right_m', 'right_end'],
            []
        )

    @graken()
    def _top_statement_(self):
        with self._choice():
            with self._option():
                with self._if():
                    with self._group():
                        self._token('for')
                self._token('for')
                self._ID_()
                self._token('in')
                self._variable_()
                self._implementation_()
            with self._option():
                self._variable_()
                self._token('=')
                self._operand_()
            with self._option():
                self._call_()
            self._error('no available options')

    @graken()
    def _implementation_(self):
        self._token(':')
        with self._optional():
            self._ML_STRING_()

        def block0():
            self._statement_()
        self._closure(block0)
        self._token('end')

    @graken()
    def _statement_(self):
        self._top_statement_()

    @graken()
    def _parameter_(self):
        self._ID_()
        self._token('=')
        self._operand_()

    @graken()
    def _constructor_(self):
        self._class_ref_()
        self._token('(')
        with self._optional():
            self._param_list_()
        self._token(')')

    @graken()
    def _param_list_(self):
        self._parameter_()

        def block0():
            self._token(',')
            self._parameter_()
        self._closure(block0)
        with self._optional():
            self._token(',')

    @graken()
    def _operand_(self):
        with self._choice():
            with self._option():
                self._constant_()
            with self._option():
                self._list_def_()
            with self._option():
                self._index_lookup_()
            with self._option():
                self._call_()
            with self._option():
                self._variable_()
            self._error('no available options')

    @graken()
    def _constant_(self):
        with self._choice():
            with self._option():
                self._TRUE_()
            with self._option():
                self._FALSE_()
            with self._option():
                self._STRING_()
            with self._option():
                self._INT_()
            with self._option():
                self._FLOAT_()
            with self._option():
                self._REGEX_()
            with self._option():
                self._ML_STRING_()
            self._error('no available options')

    @graken()
    def _list_def_(self):
        self._token('[')
        self._operand_()

        def block0():
            self._token(',')
            self._operand_()
        self._closure(block0)
        with self._optional():
            self._token(',')
        self._token(']')

    @graken()
    def _index_arg_(self):
        self._param_list_()

    @graken()
    def _index_lookup_(self):
        self._class_ref_()
        self._token('[')
        self._index_arg_()
        self._token(']')

    @graken()
    def _entity_body_(self):
        self._ns_ref_()
        self._ID_()
        with self._optional():
            self._token('=')
            self._constant_()

    @graken()
    def _ns_ref_(self):
        self._ID_()

        def block0():
            self._token('::')
            self._ID_()
        self._closure(block0)

    @graken()
    def _class_ref_(self):

        def block0():
            self._ID_()
            self.add_last_node_to_name('ns')
            self._token('::')
        self._closure(block0)
        self._CLASS_ID_()

        self.ast._define(
            [],
            ['ns']
        )

    @graken()
    def _variable_(self):

        def block0():
            self._ID_()
            self.add_last_node_to_name('ns')
            self._token('::')
        self._closure(block0)
        self._ID_()
        self.name_last_node('var')

        def block3():
            self._token('.')
            self._ID_()
            self.add_last_node_to_name('attr')
        self._closure(block3)

        self.ast._define(
            ['var'],
            ['ns', 'attr']
        )

    @graken()
    def _arg_list_(self):
        self._operand_()

        def block0():
            self._token(',')
            self._operand_()
        self._closure(block0)
        with self._optional():
            self._token(',')

    @graken()
    def _call_(self):
        with self._choice():
            with self._option():
                with self._if():
                    with self._group():
                        self._ns_ref_()
                        self._token('(')
                self._function_call_()
            with self._option():
                with self._if():
                    with self._group():
                        self._class_ref_()
                        self._token('(')
                self._constructor_()
            self._error('no available options')

    @graken()
    def _function_call_(self):
        self._ns_ref_()
        self._token('(')
        with self._optional():
            self._arg_list_()
        self._token(')')

    @graken()
    def _un_op_(self):
        self._token('not')

    @graken()
    def _cmp_op_(self):
        with self._choice():
            with self._option():
                self._token('==')
            with self._option():
                self._token('!=')
            with self._option():
                self._token('<=')
            with self._option():
                self._token('>=')
            with self._option():
                self._token('<')
            with self._option():
                self._token('>')
            self._error('expecting one of: != < <= == > >=')

    @graken()
    def _cmp_(self):
        with self._choice():
            with self._option():
                with self._if():
                    with self._group():
                        self._operand_()
                        self._token('in')
                self._operand_()
                self._token('in')
                self._in_oper_()
            with self._option():
                with self._if():
                    with self._group():
                        self._operand_()
                        self._cmp_op_()
                self._operand_()
                self._cmp_op_()
                self._operand_()
            with self._option():
                self._function_call_()
            self._error('no available options')

    @graken()
    def _log_op_(self):
        with self._choice():
            with self._option():
                self._token('and')
            with self._option():
                self._token('or')
            self._error('expecting one of: and or')

    @graken()
    def _in_oper_(self):
        with self._choice():
            with self._option():
                self._list_def_()
            with self._option():
                self._variable_()
            self._error('no available options')

    @graken()
    def _log_oper_(self):
        with self._choice():
            with self._option():
                self._cmp_()
            with self._option():
                self._TRUE_()
            with self._option():
                self._FALSE_()
            self._error('no available options')

    @graken()
    def _log_expr_(self):
        with self._choice():
            with self._option():
                with self._if():
                    with self._group():
                        self._log_oper_()
                        self._log_op_()
                self._log_oper_()
                self._log_op_()
                self._log_expr_()
            with self._option():
                self._log_oper_()
            self._error('no available options')

    @graken()
    def _expression_(self):
        with self._choice():
            with self._option():
                self._token('(')
                self._expression_()
                self._token(')')
                with self._optional():
                    self._log_op_()
                    self._expression_()
            with self._option():
                with self._if():
                    with self._group():
                        self._log_expr_()
                        self._log_op_()
                self._log_expr_()
                self._log_op_()
                self._token('(')
                self._expression_()
                self._token(')')
            with self._option():
                self._log_expr_()
            self._error('no available options')

    @graken()
    def _TRUE_(self):
        self._token('true')

    @graken()
    def _FALSE_(self):
        self._token('false')

    @graken()
    def _ID_(self):
        with self._group():
            self._pattern(r'[a-z_][a-zA-Z0-9_-]*')

    @graken()
    def _CLASS_ID_(self):
        with self._group():
            self._pattern(r'[A-Z][a-zA-Z_0-9-]*')

    @graken()
    def _INT_(self):

        def block0():
            self._pattern(r'[0-9]')
        self._positive_closure(block0)

    @graken()
    def _FLOAT_(self):
        with self._choice():
            with self._option():

                def block0():
                    self._pattern(r"['0'-'9']")
                self._positive_closure(block0)
                self._token('.')

                def block1():
                    self._pattern(r"['0'-'9']")
                self._closure(block1)
                with self._optional():
                    self._EXPONENT_()
            with self._option():
                self._token('.')

                def block2():
                    self._pattern(r"['0'-'9']")
                self._positive_closure(block2)
                with self._optional():
                    self._EXPONENT_()
            with self._option():

                def block3():
                    self._pattern(r"['0'-'9']")
                self._positive_closure(block3)
                self._EXPONENT_()
            self._error("expecting one of: . ['0'-'9']")

    @graken()
    def _COMMENT_(self):
        with self._choice():
            with self._option():
                self._token('//')

                def block0():
                    with self._ifnot():
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._token('\\n')
                                with self._option():
                                    self._token('\\r')
                                self._error('expecting one of: \\n \\r')
                    self._pattern(r'.')
                self._closure(block0)
                with self._optional():
                    self._token('\\r')
                self._token('\\n')
            with self._option():
                self._token('#')

                def block2():
                    with self._ifnot():
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._token('\\n')
                                with self._option():
                                    self._token('\\r')
                                self._error('expecting one of: \\n \\r')
                    self._pattern(r'.')
                self._closure(block2)
                with self._optional():
                    self._token('\\r')
                self._token('\\n')
            with self._option():
                self._token('/*')

                def block4():
                    with self._group():
                        self._pattern(r'\w+|\S+')
                self._closure(block4)
                self._token('*/')
            self._error('expecting one of: # /* //')

    @graken()
    def _WS_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token(' ')
                with self._option():
                    self._token('\\t')
                with self._option():
                    self._token('\\r')
                with self._option():
                    self._token('\\n')
                self._error('expecting one of:   \\n \\r \\t')

    @graken()
    def _ML_STRING_(self):
        self._token('"""')

        def block0():
            with self._group():
                self._pattern(r'\w+|\S+')
        self._closure(block0)
        self._token('"""')

    @graken()
    def _STRING_(self):
        self._pattern(r'"[^"]*"')

    @graken()
    def _REGEX_(self):
        self._token('/')

        def block0():
            with self._ifnot():
                with self._group():
                    self._token('/')
            self._pattern(r'.')
        self._closure(block0)
        self._token('/')

    @graken()
    def _EXPONENT_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('e')
                with self._option():
                    self._token('E')
                self._error('expecting one of: E e')
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('-')
                self._error('expecting one of: + -')

        def block2():
            self._pattern(r"['0'-'9']")
        self._positive_closure(block2)

    @graken()
    def _HEX_DIGIT_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern(r"['0'-'9']")
                with self._option():
                    self._pattern(r"['a'-'f']")
                with self._option():
                    self._pattern(r"['A'-'F']")
                self._error("expecting one of: ['0'-'9'] ['A'-'F'] ['a'-'f']")

    @graken()
    def _ESC_SEQ_(self):
        with self._choice():
            with self._option():
                self._token('\\\\')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('b')
                        with self._option():
                            self._token('t')
                        with self._option():
                            self._token('n')
                        with self._option():
                            self._token('f')
                        with self._option():
                            self._token('r')
                        with self._option():
                            self._token('\\"')
                        with self._option():
                            self._token("\\'")
                        with self._option():
                            self._token('\\\\')
                        self._error('expecting one of: \\" \\\' \\\\ b f n r t')
            with self._option():
                self._UNICODE_ESC_()
            with self._option():
                self._OCTAL_ESC_()
            self._error('expecting one of: \\\\')

    @graken()
    def _OCTAL_ESC_(self):
        with self._choice():
            with self._option():
                self._token('\\\\')
                with self._group():
                    self._pattern(r"['0'-'3']")
                with self._group():
                    self._pattern(r"['0'-'7']")
                with self._group():
                    self._pattern(r"['0'-'7']")
            with self._option():
                self._token('\\\\')
                with self._group():
                    self._pattern(r"['0'-'7']")
                with self._group():
                    self._pattern(r"['0'-'7']")
            with self._option():
                self._token('\\\\')
                with self._group():
                    self._pattern(r"['0'-'7']")
            self._error('expecting one of: \\\\')

    @graken()
    def _UNICODE_ESC_(self):
        self._token('\\\\')
        self._token('u')
        self._HEX_DIGIT_()
        self._HEX_DIGIT_()
        self._HEX_DIGIT_()
        self._HEX_DIGIT_()


class imperaSemantics(object):
    def main(self, ast):
        return ast

    def def_statement(self, ast):
        return ast

    def typedef(self, ast):
        return ast

    def entity_def(self, ast):
        return ast

    def implementation_def(self, ast):
        return ast

    def index(self, ast):
        return ast

    def implement_def(self, ast):
        return ast

    def relation_end(self, ast):
        return ast

    def relation_link(self, ast):
        return ast

    def multiplicity_body(self, ast):
        return ast

    def multiplicity(self, ast):
        return ast

    def relation(self, ast):
        return ast

    def top_statement(self, ast):
        return ast

    def implementation(self, ast):
        return ast

    def statement(self, ast):
        return ast

    def parameter(self, ast):
        return ast

    def constructor(self, ast):
        return ast

    def param_list(self, ast):
        return ast

    def operand(self, ast):
        return ast

    def constant(self, ast):
        return ast

    def list_def(self, ast):
        return ast

    def index_arg(self, ast):
        return ast

    def index_lookup(self, ast):
        return ast

    def entity_body(self, ast):
        return ast

    def ns_ref(self, ast):
        return ast

    def class_ref(self, ast):
        return ast

    def variable(self, ast):
        return ast

    def arg_list(self, ast):
        return ast

    def call(self, ast):
        return ast

    def function_call(self, ast):
        return ast

    def un_op(self, ast):
        return ast

    def cmp_op(self, ast):
        return ast

    def cmp(self, ast):
        return ast

    def log_op(self, ast):
        return ast

    def in_oper(self, ast):
        return ast

    def log_oper(self, ast):
        return ast

    def log_expr(self, ast):
        return ast

    def expression(self, ast):
        return ast

    def TRUE(self, ast):
        return ast

    def FALSE(self, ast):
        return ast

    def ID(self, ast):
        return ast

    def CLASS_ID(self, ast):
        return ast

    def INT(self, ast):
        return ast

    def FLOAT(self, ast):
        return ast

    def COMMENT(self, ast):
        return ast

    def WS(self, ast):
        return ast

    def ML_STRING(self, ast):
        return ast

    def STRING(self, ast):
        return ast

    def REGEX(self, ast):
        return ast

    def EXPONENT(self, ast):
        return ast

    def HEX_DIGIT(self, ast):
        return ast

    def ESC_SEQ(self, ast):
        return ast

    def OCTAL_ESC(self, ast):
        return ast

    def UNICODE_ESC(self, ast):
        return ast


def main(
        filename,
        startrule,
        trace=False,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re='(#.*?$)',
        ignorecase=None,
        left_recursion=True,
        **kwargs):

    with open(filename) as f:
        text = f.read()
    parser = imperaParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace,
        nameguard=nameguard,
        ignorecase=ignorecase,
        **kwargs)
    return ast

if __name__ == '__main__':
    import json
    ast = generic_main(main, imperaParser, name='impera')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()
