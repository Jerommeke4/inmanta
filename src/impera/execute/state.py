"""
    Copyright 2015 Impera

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    Contact: bart@impera.io
"""

import copy

from impera.ast import Namespace
from impera.ast.statements.call import BooleanExpression
from impera.ast.variables import ResultVariable
from impera.ast.variables import Reference
from impera.ast.variables import Variable
from impera.ast.variables import AttributeVariable
from impera.execute.scope import Scope


def get_ref(state, value):
    """
        Prepare a value from the compiler to be used during evaluation

        @param state: The state of the statement that has "value"
        @param value: A value generated by the compiler
        @return A value that can be used during evaluation without changing
            the statement itself
    """
    if hasattr(value, "to_function"):
        # let expression generate an evaluator for the operator/expression in
        # value
        expr = BooleanExpression(value, None)
        return get_ref(state, expr)

    elif isinstance(value, BooleanExpression):
        child_state = state.add_statement(value, child_ns=True)
        return child_state.get_result_reference()

    elif hasattr(value, "evaluate"):
        # add this statement and store a reference
        # value.namespace = state.statement.namespace
        child_state = state.add_statement(value)
        return child_state.get_result_reference()

    elif value.__class__ == Reference:
        return value

    elif isinstance(value, AttributeVariable):
        return copy.deepcopy(value)

    elif isinstance(value, Variable):

        return value

    else:
        return Variable(value)


class State(object):
    """
        This class represents a statement that is being evaluated. This class
        links to the statement and holds the state during the execution.

        @param graph: The graph that contains the state of the compiler
        @param namespace: The namespace this statement is used in. This can be
            the statement it is defined in, but can also be the namespace it
            is included in.
        @param statement: The statement this state is linked with. This
            statement contains the logic of this state.
    """

    def __init__(self, compiler, namespace, statement):
        self.compiler = compiler
        self.graph = None
        self.statement = statement
        self.namespace = namespace

        self._required_types = {}
        self._resolved_types = {}

        self.evaluated = False

    def add_to_graph(self, graph):
        """
            Add this statement to the graph
        """
        self.graph = graph
        self.graph.add_statement(self)

        for name, type_ref in self.statement.types():
            if len(type_ref.namespace) == 0:
                type_ref = Reference(type_ref.name, self.statement.namespace.to_path())
            self._required_types[name] = type_ref

    def get_local_scope(self):
        """
            Get the scope in which the statement will be evaluated
        """
        scope = Scope.get_or_create_scope(self.graph, self.namespace.to_path())
        scope.filename = self.statement.filename
        scope.line = self.statement.line

        return scope

    def get_type(self, name):
        """
            Get the type identified by name
        """
        return self._resolved_types[name]

    def has_type(self, name):
        """
            Is the variable with name resolved?
        """
        return name in self._resolved_types

    def set_evaluated(self):
        """
            Mark this state as evaluated
        """
        self.evaluated = True

    def resolved(self):
        """
            If all types are resolved it can be evaluated.
        """
        if len(self._required_types) == len(self._resolved_types):
            return True

        local_scope = self.get_local_scope()

        result = False
        for name, type_ref in self._required_types.items():
            if name in self._resolved_types:
                continue

            result = type_ref.is_available(local_scope)
            if result:
                self._resolved_types[name] = local_scope.resolve_reference(type_ref).value

        return len(self._required_types) == len(self._resolved_types)

    def can_evaluate(self):
        """
            Can this statement be evaluated?
        """
        return self.resolved()

    def evaluate(self):
        """
            Evaluate this statement and if successful mark it as evaluated.
        """
        local_scope = self.get_local_scope()
        self.statement.evaluate(self, local_scope)
        self.set_evaluated()

    def __repr__(self):
        """
            The representation of this object. Used for debugging and logging.
        """
        return repr(self.statement) + " " + hex(id(self))


class DynamicState(State):
    """
        Represents a dynamic state
    """

    def __init__(self, compiler, namespace, statement):
        State.__init__(self, compiler, namespace, statement)
        self._result = None
        self._child_statements = {}
        self.__attributes = {}

        self._refs = {}
        self._resolved = False

        self._result_ref = ResultVariable(self)

    def add_to_graph(self, graph):
        """
            @see State#add_to_graph

            This method ensures that the statement can be statically executed,
            which means that all types have been resolved.
        """
        State.add_to_graph(self, graph)

        # make sure all types are resolved
        if not State.resolved(self):
            # provide a meaningful error
            for req_type in self._required_types:
                if req_type not in self._resolved_types:
                    type_name = str(self._required_types[req_type])
                    raise Exception("Unable to resolve %s for statement %s in file %s:%d" %
                                    (type_name, self.statement, self.statement.filename, self.statement.line))

            raise Exception("Unable to resolve all required types")

        # get all references this statement needs
        for ref_def in self.statement.references():
            name = ref_def[0]
            value = ref_def[1]
            ref_type = "use"

            if len(ref_def) > 2:
                ref_type = ref_def[2]

            self.add_ref(name, value, ref_type)

        # add any statements under this node to the graph as well
        self.statement.new_statements(self)

    def resolved(self):
        """
            Are all dynamic references of this statement resolved?
        """
        if self._resolved:
            return True

        scope = self.get_local_scope()
        for ref in self._refs.values():
            if not ref.is_available(scope):
                return False

        self._resolved = True
        self.graph.add_actions(self, self.statement.actions(self))
        return True

    def can_evaluate(self):
        """
            Can this statement be evaluated in the current state it is in?
        """
        if not self.graph.can_evaluate(self):
            return False

        return self.statement.can_evaluate(self)

    def get_ref(self, name):
        """
            Get a reference
        """
        if name not in self._refs:
            return None

        reference = self._refs[name]

        if reference.__class__ == Reference:
            return self.get_local_scope().resolve_reference(reference)

        return reference

    def add_ref(self, name, value, ref_type="use"):
        """
            Allow statements to add references
        """
        if ref_type == "use":
            value_ref = get_ref(self, value)
            self._refs[name] = value_ref

        elif ref_type == "def":
            scope = self.get_local_scope()
            scope.add_placeholder(name.name)

        else:
            raise Exception("Unknown ref type given by %s" % self)

    def get_result(self):
        """
            Get the result of evaluating this statement
        """
        return self._result

    def get_result_reference(self):
        """
            This method returns a reference to a result
        """
        return self._result_ref

    def set_evaluated(self):
        """
            Mark this state as evaluated
        """
        State.set_evaluated(self)

    def evaluate(self):
        """
            Evaluate this statement and if successful mark it as evaluated.

            @param force: Force the evaluation even if the statement is lazy.
        """
        local_scope = self.get_local_scope()

        value = self.statement.evaluate(self, local_scope)

        if hasattr(value, "instance"):  # still wrapped with proxy
            raise Exception("Statements should unwrap proxied instances!")

        if not isinstance(value, Variable):
            value = Variable(value)

        self._result = value

        if self._result is not None:
            self._result_ref.value_available()

       #     if self._result_ref.value is None:
       #         self._result_ref.value
       #         raise Exception("odd")

        self.set_evaluated()

    def get_state(self, statement):
        """
            Get the state of a statement that has been added to the graph by
            this state.
        """
        if statement in self._child_statements:
            return self._child_statements[statement]

        raise KeyError()

    def add_statement(self, statement, child_ns=False):
        """
            Add a new statement that is generated or included by the statement
            linked to this state. The new statement is defined in the
            same namespace as this statement or in a child namespace.

            @param statement: The new statement
            @param child_ns: Optional can be set to true to define it in a child
                namespace.
        """
        if statement in self._child_statements:
            raise Exception("Statement %s already added by %s" % (statement, self))

        namespace = self.namespace
        if child_ns:
            object_id = Scope.object_to_name(self)
            namespace = Namespace(object_id, self.namespace)

        child_state = DynamicState(self.compiler, namespace, statement)
        child_state.add_to_graph(self.graph)
        self._child_statements[statement] = child_state

        return child_state

    def get_attribute(self, name):
        """
            Get an attribute that is stored in this state
        """
        if name in self.__attributes:
            return self.__attributes[name]

        raise KeyError(name)

    def set_attribute(self, name, value):
        """
            Set a value in this state
        """
        self.__attributes[name] = value

    def has_attribute(self, name):
        """
            Is the attribute with name set?
        """
        return name in self.__attributes
